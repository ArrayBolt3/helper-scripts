#!/usr/bin/env bash
#
# Script Name: curl-prgrs
#
# Description:
# The curl-prgrs script augments the functionality of curl by adding a custom progress bar
# for file downloads, making it a convenient drop-in replacement for curl with the added
# benefit of visual progress tracking. It accepts the same command-line arguments and options as curl.
#
# Additionally, this script provides a mechanism to mitigate endless data attacks (as defined
# in the TUF threat model) by setting the CURL_PRGRS_MAX_FILE_SIZE_BYTES environment variable.
# Unlike curl's --max-filesize option, which does not have an effect when the file size is unknown prior to download,
# this script ensures the file size restriction is enforced. The limitation of curl's --max-filesize is acknowledged in
# the curl man page as follows:
# "NOTE: The file size is not always known prior to download, and for such files this
# option has no effect even if the file transfer ends up being larger than this given limit."
#
# Usage:
# Substitute curl with curl-prgrs for downloading files:
#     $ curl-prgrs -O http://example.com/file.tar.gz
#     $ curl-prgrs http://example.com/file.tar.gz > file.tar.gz
#
# Features:
# - Displays a custom-drawn progress bar to visualize download progress.
# - Provides error handling and cleanup for various termination scenarios.
# - Conducts preliminary checks for required dependencies before proceeding.
# - Utilizes temporary files for capturing progress information and facilitating process communication.
# - Allows custom configurations via environment variables.
#
# Environment Variables:
# - TMPDIR: Specifies the path to the temporary directory.
# - CURL: Defines the path to the curl binary. Acceptable values are "curl" or "scurl" (secure curl). Default: "curl"
# - CURL_PRGRS_MAX_FILE_SIZE_BYTES: Sets the maximum allowed file size for downloads in bytes. Default: unset
# - CURL_OUT_FILE: Specifies the path to the output file for download. Required when using CURL_PRGRS_MAX_FILE_SIZE_BYTES. Default: unset
# - CURL_PRGRS_EXEC: Designates the command to execute for updating the progress bar. Default: unset
#
# Authors:
# - Sam Stephenson <sstephenson@gmail.com>
# - Patrick Schleizer <adrelanos@whonix.org>
#
# License:
# (c) 2013 Sam Stephenson <sstephenson@gmail.com>
# Released into the public domain on 2013-01-21.
# Source: https://gist.github.com/sstephenson/4587282
#
# Modifications:
# - Subsequent modifications by Patrick Schleizer under the same license.
#
# Technical Overview:
# The script initiates by forking curl into the background, directing a temporary file to the `--trace-ascii`
# option. It filters and parses the trace output line-by-line to extract progress information, which is then
# utilized to update and display the progress bar on the terminal as data is received.

#set -x
set -e
set -o nounset
set -o pipefail

is_number() {
    [[ $1 =~ ^-?[0-9]+$ ]]
}

# We want to print the progress bar to stderr, but only if stderr is a
# terminal. To avoid a conditional every time we print something, we can
# instead print everything to file descriptor 4, and then point that file
# descriptor to the right place: stderr if it's a TTY, or /dev/null
# otherwise.
if [ -t 2 ]; then
  exec 4>&2
else
  exec 4>/dev/null
fi

command -v tput >/dev/null
command -v sed >/dev/null
command -v mkfifo >/dev/null
command -v curl >/dev/null
command -v rm >/dev/null
command -v mktemp >/dev/null

: "${TERM:=""}"
: "${TMPDIR:=""}"
: "${CURL:="curl"}"
: "${CURL_DOWNLOAD_FILE_SIZE_BYTES:=""}"
: "${CURL_PRGRS_MAX_FILE_SIZE_BYTES:=""}"
: "${CURL_OUT_FILE:=""}"
: "${CURL_PRGRS_EXEC:=""}"
percent_last=""
counter_progress_delay="10"

if [ "$CURL_OUT_FILE" = "" ]; then
  echo "$BASH_SOURCE ERROR: Variable CURL_OUT_FILE is empty." >&4
  exit "57"
fi
if [ "$CURL_PRGRS_MAX_FILE_SIZE_BYTES" = "" ]; then
  echo "$BASH_SOURCE ERROR: Variable CURL_PRGRS_MAX_FILE_SIZE_BYTES is empty." >&4
  exit "57"
fi

is_number "$CURL_PRGRS_MAX_FILE_SIZE_BYTES"

# Locate the path to the temporary directory.
if [ "$TMPDIR" = "" ]; then
  temp_dir_auto_generated=true
  TMP="$(mktemp --directory)"
else
  temp_dir_auto_generated=false
  TMP="$TMPDIR"
fi

# Compute names for our temporary files by joining the current date and
# time with the current process ID. We will need two temporary files: one
# for reading progress information from curl, and another for sending the
# exit status of curl from the forked child process back to the parent.
statusfile="${TMP}/status"

# Define our `shutdown` function, which will be responsible for cleaning
# up when the program terminates, either normally or abnormally.
shutdown() {
  local exit_code="$?"
  local signal="$1"
  local last_err="$BASH_COMMAND"
  if [ "$signal" = "err" ]; then
    echo "$BASH_SOURCE ERROR: Signal $signal received. Exiting." >&4
    echo "$BASH_SOURCE: ERROR: BASH_COMMAND '$BASH_COMMAND' exit code '$exit_code'." >&4
    error_exit_code=110
  elif [ "$signal" = "exit" ]; then
    true "$BASH_SOURCE INFO: Signal $signal received. Exiting." >&4
  else
    echo "$BASH_SOURCE INFO: Signal $signal received. Exiting." >&4
  fi

  trap - SIGHUP SIGINT SIGTERM ERR EXIT

  # If we wrote an exit status to the temporary file, read it. Otherwise,
  # we reached this trap function abnormally; assume a non-zero status.

  sync

  local status

  if [ -f "$statusfile" ]; then
    true "$BASH_SOURCE: INFO: got status file"
    status="$(cat "$statusfile")"
    if ! is_number "$status"; then
      true "$0: status is not a number! status: '$status'"
      status="111"
      error_exit_code="111"
    fi
  else
    true "$BASH_SOURCE ERROR: no status file"
    status="112"
    error_exit_code="112"
  fi

  # If we are exiting normally, jump back to the beginning of the line
  # and clear it. Otherwise, print a newline.
  if [ "$status" -eq 0 ]; then
    printf "\x1B[0G\x1B[0K" >&4
  else
    echo >&4
  fi

  #stat="$(cat "$statusfile")"
  #echo "$stat" >&4

  if [ "$temp_dir_auto_generated" = "true" ]; then
    rm -r -f "$TMP"
  fi

  true curl_pid
  : "${curl_pid:=""}"

  processes_list="$curl_pid"
  for processes_item in $processes_list ; do
    if kill -0 "$processes_item" 2>/dev/null ; then
      #ps -p "$processes_item" || true
      kill -s sigkill "$processes_item" &>/dev/null || true
    fi
  done

  if [ -n "${error_exit_code-}" ]; then
     true "INFO: exit with error_exit_code $error_exit_code"
     exit "$error_exit_code"
  fi

  true "INFO: exit with status $status"
  exit "$status"
}

# Register our `shutdown` function to be invoked when the process dies.
trap "shutdown sigint" SIGINT
trap "shutdown sigterm" SIGTERM
trap "shutdown err" ERR
trap "shutdown exit" EXIT
trap "shutdown sighup" SIGHUP

# The `print_progress` function draws our progress bar to the screen. It
# takes two arguments: the number of bytes read so far, and the total
# number of bytes expected.
print_progress() {
  local bytes="$1"
  local length="$CURL_DOWNLOAD_FILE_SIZE_BYTES"

  # If we are expecting less than 8 KB of data, don't bother drawing a
  # progress bar. (This helps avoid a flicker when following redirects.)
  #[ "$length" -gt 8192 ] || return 0

  # Calculate the progress percentage and the size of the filled and
  # unfilled portions of the progress bar.
  local percent
  percent=$(( $bytes * 100 / $length ))

  if [ "$percent" -ge "100" ]; then
    percent=100
  fi

  if [ "$TERM" = "" ]; then
    true
  elif [ "$percent_last" = "$percent" ]; then
    true
  else
    # Get the width of the terminal and reserve space for the percentage.
    ## Added '-Tdumb' in case above 'if [ "$TERM" = "" ]; then' does not match
    ## due to unknown bug.
    ## Added '2>/dev/null' to avoid log spam
    ## 'tput: No value for $TERM and no -T specified' because of above.
    : "${columns:="$(tput -Tdumb cols 2>/dev/null)"}"
    local width
    width=$(( $columns - 10 ))
    local on
    on=$(( $bytes * $width / $length ))
    local off
    off=$(( $width - $on ))

    # Using ANSI escape sequences, first move the cursor to the beginning
    # of the line, and then write the percentage. Switch to inverted text
    # mode and print spaces to represent the filled part of the progress
    # bar, then reset and print spaces for the remainder of the region.
    # Finally, move the cursor back one character so it rests at the end of
    # the progress bar.
    printf "\x1B[0G %-6s\x1B[7m%*s\x1B[0m%*s\x1B[1D" \
      "${percent}%" "$on" "" "$off" "" >&4
  fi

  if [ "$CURL_PRGRS_EXEC" = "" ]; then
    return 0
  fi

  percent_last="$percent"
  #echo "$BASH_SOURCE CURL_PRGRS_EXEC: $CURL_PRGRS_EXEC" >&4
  eval $CURL_PRGRS_EXEC >&4
}

curl_exit() {
  curl_exit_code="$1"
  true "write $curl_exit_code to $statusfile"
  echo "$curl_exit_code" > "$statusfile"
  if [ "$curl_exit_code" = "0" ]; then
    return 0
  fi
  if ! kill -0 "$curl_pid" 2>/dev/null; then
    kill -s SIGKILL "$curl_pid" &>/dev/null || true
  fi
}

curl_download() {
  $CURL --no-progress-meter "$@" &
  curl_pid=$!

  while true ; do
    if [ -f "$CURL_OUT_FILE" ]; then
      bytes=$(stat -c%s "$CURL_OUT_FILE")

      if ! is_number "$bytes" ; then
        curl_exit 113
      fi

      if [ "$bytes" -gt "$CURL_PRGRS_MAX_FILE_SIZE_BYTES" ]; then
        curl_exit 81
      fi

      if [ ! "$CURL_DOWNLOAD_FILE_SIZE_BYTES" = "" ]; then
        if [ "$bytes" -ge "$CURL_DOWNLOAD_FILE_SIZE_BYTES" ]; then

          curl_exit 114
        fi
      fi

      if [ ! "$CURL_DOWNLOAD_FILE_SIZE_BYTES" = "" ]; then
        print_progress "$bytes"
      fi
    fi

    if ! kill -0 "$curl_pid" 2>/dev/null; then
        break
    fi

    sleep 1
  done

  if [ ! "$CURL_DOWNLOAD_FILE_SIZE_BYTES" = "" ]; then
    if [ "$bytes" -le "$CURL_DOWNLOAD_FILE_SIZE_BYTES" ]; then
      curl_exit 115
    fi
  fi

  curl_exit_code=0
  wait "$curl_pid" || { curl_exit_code=$? ; true; };
  curl_exit "$curl_exit_code"
}

CURL_DOWNLOAD_FILE_SIZE_BYTES=$(curl_download --head --write-out '%header{Content-Length}\n' "$@")
curl_download "$@" &

wait_exit_code=0
wait "$!" &>/dev/null || { wait_exit_code=$? ; true; };
true "$BASH_SOURCE INFO: END."
exit "$wait_exit_code"
