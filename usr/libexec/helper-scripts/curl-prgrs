#!/usr/bin/env bash
#
# Script Name: curl-prgrs
#
# Description:
# The curl-prgrs script augments the functionality of curl by adding a custom progress bar
# for file downloads, making it a convenient drop-in replacement for curl with the added
# benefit of visual progress tracking. It accepts the same command-line arguments and options as curl.
#
# Additionally, this script provides a mechanism to mitigate endless data attacks (as defined
# in the TUF threat model) by setting the CURL_PRGRS_MAX_FILE_SIZE_BYTES environment variable.
# Unlike curl's --max-filesize option, which does not have an effect when the file size is unknown prior to download,
# this script ensures the file size restriction is enforced. The limitation of curl's --max-filesize is acknowledged in
# the curl man page as follows:
# "NOTE: The file size is not always known prior to download, and for such files this
# option has no effect even if the file transfer ends up being larger than this given limit."
#
# Usage:
# Substitute curl with curl-prgrs for downloading files:
#     $ curl-prgrs -O http://example.com/file.tar.gz
#     $ curl-prgrs http://example.com/file.tar.gz > file.tar.gz
#
# Features:
# - Displays a custom-drawn progress bar to visualize download progress.
# - Provides error handling and cleanup for various termination scenarios.
# - Conducts preliminary checks for required dependencies before proceeding.
# - Utilizes temporary files for capturing progress information and facilitating process communication.
# - Allows custom configurations via environment variables.
#
# Environment Variables:
# - TMPDIR: Specifies the path to the temporary directory.
# - CURL: Defines the path to the curl binary. Acceptable values are "curl" or "scurl" (secure curl). Default: "curl"
# - CURL_PRGRS_MAX_FILE_SIZE_BYTES: Sets the maximum allowed file size for downloads in bytes. Default: unset
# - CURL_OUT_FILE: Specifies the path to the output file for download. Required when using CURL_PRGRS_MAX_FILE_SIZE_BYTES. Default: unset
# - CURL_PRGRS_EXEC: Designates the command to execute for updating the progress bar. Default: unset
#
# Authors:
# - Sam Stephenson <sstephenson@gmail.com>
# - Patrick Schleizer <adrelanos@whonix.org>
#
# License:
# (c) 2013 Sam Stephenson <sstephenson@gmail.com>
# Released into the public domain on 2013-01-21.
# Source: https://gist.github.com/sstephenson/4587282
#
# Modifications:
# - Subsequent modifications by Patrick Schleizer under the same license.
#
# Technical Overview:
# The script initiates by forking curl into the background, directing a temporary file to the `--trace-ascii`
# option. It filters and parses the trace output line-by-line to extract progress information, which is then
# utilized to update and display the progress bar on the terminal as data is received.

#set -x
set -e
set -o nounset
set -o pipefail

isnum() {
    local num="$1"
    [[ $num =~ ^-?[0-9]+$ ]] && return 0 || return 1
}

# We want to print the progress bar to stderr, but only if stderr is a
# terminal. To avoid a conditional every time we print something, we can
# instead print everything to file descriptor 4, and then point that file
# descriptor to the right place: stderr if it's a TTY, or /dev/null
# otherwise.
if [ -t 2 ]; then
  exec 4>&2
else
  exec 4>/dev/null
fi

command -v tput >/dev/null
command -v sed >/dev/null
command -v mkfifo >/dev/null
command -v curl >/dev/null
command -v rm >/dev/null
command -v mktemp >/dev/null

: "${TMPDIR:=""}"
: "${CURL:="curl"}"
: "${CURL_PRGRS_MAX_FILE_SIZE_BYTES:=""}"
: "${CURL_OUT_FILE:=""}"
: "${CURL_PRGRS_EXEC:=""}"

# Locate the path to the temporary directory.
if [ "$TMPDIR" = "" ]; then
  temp_dir_auto_generated=true
  TMP="$(mktemp --directory)"
else
  temp_dir_auto_generated=false
  TMP="$TMPDIR"
fi

# Compute names for our temporary files by joining the current date and
# time with the current process ID. We will need two temporary files: one
# for reading progress information from curl, and another for sending the
# exit status of curl from the forked child process back to the parent.
tracefile="${TMP}/trace"
statusfile="${TMP}/status"

# Remove the temporary files if they somehow already exist.
rm -f "$tracefile" "$statusfile"

# Define our `shutdown` function, which will be responsible for cleaning
# up when the program terminates, either normally or abnormally.
shutdown() {
  local exit_code="$?"
  local signal="$1"
  local last_err="$BASH_COMMAND"
  if [ "$signal" = "err" ]; then
    echo "$BASH_SOURCE ERROR: Signal $signal received. Exiting." >&4
    echo "$BASH_SOURCE: ERROR: BASH_COMMAND '$BASH_COMMAND' exit code '$exit_code'." >&4
    error_exit_code=110
  else
    echo "$BASH_SOURCE INFO: Signal $signal received. Exiting." >&4
  fi

  trap - SIGHUP SIGINT SIGTERM ERR EXIT

  # If we wrote an exit status to the temporary file, read it. Otherwise,
  # we reached this trap function abnormally; assume a non-zero status.

  sync

  local status

  if [ -f "$statusfile" ]; then
    true "$BASH_SOURCE: INFO: got status file"
    status="$(cat "$statusfile")"
    if ! isnum "$status"; then
      true "$0: status is not a number! status: '$status'"
      status="111"
      error_exit_code="111"
    fi
  else
    true "$BASH_SOURCE ERROR: no status file"
    status="112"
    error_exit_code="112"
  fi

  # If we are exiting normally, jump back to the beginning of the line
  # and clear it. Otherwise, print a newline.
  if [ "$status" -eq 0 ]; then
    printf "\x1B[0G\x1B[0K" >&4
  else
    echo >&4
  fi

  #stat="$(cat "$statusfile")"
  #echo "$stat" >&4

  if [ "$temp_dir_auto_generated" = "true" ]; then
    rm -r -f "$TMP"
  fi

  true curl_pid
  : "${curl_pid:=""}"
  true subshell_pid
  : "${subshell_pid:=""}"
  true sed_pid
  : "${sed_pid:=""}"

  processes_list="$curl_pid $subshell_pid $sed_pid"
  for processes_item in $processes_list ; do
    if kill -0 "$processes_item" 2>/dev/null ; then
      #ps -p "$processes_item" || true
      kill -s sigkill "$processes_item" &>/dev/null || true
    fi
  done

  if [ -n "${error_exit_code-}" ]; then
     true "INFO: exit with error_exit_code $error_exit_code"
     exit "$error_exit_code"
  fi

  true "INFO: exit with status $status"
  exit "$status"
}

# Register our `shutdown` function to be invoked when the process dies.
trap "shutdown sigint" SIGINT
trap "shutdown sigterm" SIGTERM
trap "shutdown err" ERR
trap "shutdown exit" EXIT
trap "shutdown sighup" SIGHUP

# Create our temporary progress file as a FIFO.
mkfifo "$tracefile"

# Our program begins here. Fork off a background subshell to run curl and
# record its exit status. We will pass our temporary progress FIFO to
# curl's `--trace-ascii` option, along with the `-s` option, and then any
# arguments passed to the program itself. Once curl terminates, write its
# exit status to the appropriate temporary file. Then write a single line
# to the FIFO so our loop below won't wait forever in cases where curl
# doesn't write any progress information (like when it's invoked with
# the `--help` or `--version` flag.)
( set +e
  $CURL --trace-ascii "$tracefile" -s "$@"

  curl_exit_code="$?"

  echo "$curl_exit_code" | tee "$statusfile" >/dev/null
  echo | tee -a "$tracefile" >/dev/null
  sync
) &

curl_pid="$!"


# By default, the operating system will buffer reads from the progress
# FIFO into chunks. However, we want to process the progress updates as
# soon as they are received.
unbuffered_sed() {
  # GNU sed supports a `-u` option for unbuffered reads.
  sed -nu "$@" &
  sed_pid="$!"
  wait "$sed_pid"
}


# The `print_progress` function draws our progress bar to the screen. It
# takes two arguments: the number of bytes read so far, and the total
# number of bytes expected.
print_progress() {
  local bytes="$1"
  local length="$2"

  # If we are expecting less than 8 KB of data, don't bother drawing a
  # progress bar. (This helps avoid a flicker when following redirects.)
  [ "$length" -gt 8192 ] || return 0

  # Calculate the progress percentage and the size of the filled and
  # unfilled portions of the progress bar.
  local percent
  percent=$(( $bytes * 100 / $length ))

  if [ "$TERM" = "" ]; then
    true
  else
    # Get the width of the terminal and reserve space for the percentage.
    ## Added '-Tdumb' in case above 'if [ "$TERM" = "" ]; then' does not match
    ## due to unknown bug.
    ## Added '2>/dev/null' to avoid log spam
    ## 'tput: No value for $TERM and no -T specified' because of above.
    : "${columns:="$(tput -Tdumb cols 2>/dev/null)"}"
    local width
    width=$(( $columns - 10 ))
    local on
    on=$(( $bytes * $width / $length ))
    local off
    off=$(( $width - $on ))

    # Using ANSI escape sequences, first move the cursor to the beginning
    # of the line, and then write the percentage. Switch to inverted text
    # mode and print spaces to represent the filled part of the progress
    # bar, then reset and print spaces for the remainder of the region.
    # Finally, move the cursor back one character so it rests at the end of
    # the progress bar.
    printf "\x1B[0G %-6s\x1B[7m%*s\x1B[0m%*s\x1B[1D" \
      "${percent}%" "$on" "" "$off" "" >&4
  fi

  if [ "$CURL_PRGRS_EXEC" = "" ]; then
    true
  else
    if [ "$percent_last" = "$percent" ]; then
      true
    else
      percent_last="$percent"
      #echo "$BASH_SOURCE CURL_PRGRS_EXEC: $CURL_PRGRS_EXEC" >&4
      eval $CURL_PRGRS_EXEC >&4
    fi
  fi
}


# The progress bar loop begins here. Our unbuffered `sed` will filter
# progress information from the trace output in the temporary FIFO line
# by line until curl terminates and closes the pipe. The progress
# information is normalized and passed to a loop that parses it, keeps
# track of the number of bytes received, and invokes the `print_progress`
# function accordingly. When the FIFO is closed, the loop terminates and
# bash invokes our `shutdown` exit trap.
unbuffered_sed \
  -e 'y/ACDEGHLNORTV/acdeghlnortv/' \
  -e '/^0000: content-length:/p' \
  -e '/^<= recv data/p' \
  "$tracefile" |

{

  length=0
  bytes=0

  # Read each line of filtered trace output into an array of space-
  # separated words.
  while IFS=" " read -a line; do
    tag="${line[0]} ${line[1]}"

    # If the first two words are `0000: content-length:`, extract and
    # record the expected length. We must also set the bytes-received
    # counter to zero in case we followed a redirect and this is not the
    # first response.
    if [ "$tag" = "0000: content-length:" ]; then
      length="${line[2]}"
      bytes=0

    # Otherwise, if the first two words are `<= recv`, extract the number
    # of bytes read and increment the bytes-received counter accordingly,
    # then invoke `print_progress`.
    elif [ "$tag" = "<= recv" ]; then
      size="${line[3]}"
      bytes=$(( $bytes + $size ))

      if [ "$CURL_PRGRS_MAX_FILE_SIZE_BYTES" = "" ]; then
        true
      else
        if [ "$CURL_OUT_FILE" = "" ]; then
          echo "$BASH_SOURCE ERROR: Variable CURL_OUT_FILE is empty." >&4
          error_exit_code="57"
          echo "$error_exit_code" > "$statusfile"
          exit "$error_exit_code"
        fi
        if [ "$bytes" -gt "$CURL_PRGRS_MAX_FILE_SIZE_BYTES" ]; then
          error_exit_code="81"
          echo "$error_exit_code" > "$statusfile"
          exit "$error_exit_code"
        fi
      fi

      print_progress "$bytes" "$length"
    fi
  done

} &

subshell_pid="$!"

wait_exit_code=0
wait "$!" || { wait_exit_code=$? ; true; };
true "$BASH_SOURCE INFO: END."
exit "$wait_exit_code"
