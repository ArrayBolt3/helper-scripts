#!/bin/bash

## Copyright (C) 2025 - 2025 ENCRYPTED SUPPORT LLC <adrelanos@whonix.org>
## See the file COPYING for copying conditions.

check_is_not_empty_and_only_one_line() {
   local varname value number_of_lines

   if [ -z "$1" ]; then
      echo "$0: ERROR: No variable name provided to check_is_not_empty_and_only_one_line." >&2
      return 1
   fi

   varname="$1"
   value="${!varname}"

   # Trim leading/trailing spaces while preserving newlines.
   IFS= read -r trimmed_value <<< "$value"

   # Check if value is empty or only contains spaces/newlines.
   if [[ -z "$trimmed_value" || -z "${value//[[:space:]]/}" ]]; then
      echo "$0: ERROR: Variable '$varname' is empty or contains only whitespace/newlines." >&2
      return 1
   fi

   # Count the number of lines using mapfile.
   mapfile -t lines <<< "$value"
   number_of_lines="${#lines[@]}"

   if [ "$number_of_lines" -ne 1 ]; then
      echo "$0: ERROR: Variable '$varname' contains more than one line. Content:
'$value'" >&2
      return 1
   fi

   return 0
}

run_test() {
   local test_name varname value expected_exit_code
   test_name="$1"
   varname="$2"
   value="$3"
   expected_exit_code="$4"

   eval "$varname=\"\$value\""
   echo "$0: Running test: $test_name"

   exit_code=0
   check_is_not_empty_and_only_one_line "$varname" 2>/dev/null || { exit_code=$? ; true; };

   if [ "$exit_code" -eq "$expected_exit_code" ]; then
      echo "$0: Test Passed"
   else
      echo "$0: Test Failed (Expected exit code: $expected_exit_code, Got: $exit_code)" >&2
      return 1
   fi
   echo "---------------------------------"
}

tests() {
   set -e
   set -o errtrace
   set -o pipefail
   set -o nounset

   run_test "Empty variable" "testvar1" "" 1
   run_test "Only newlines" "testvar2" "


   " 1
   run_test "Whitespace only" "testvar3" "   " 1
   run_test "Single valid line" "testvar4" "Hello, World!" 0
   run_test "Multiple lines" "testvar5" "Hello
   World" 1
   run_test "Leading and trailing spaces" "testvar6" "  Hello  " 0
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
   tests
fi
